<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Zephyr's Hub</title><link>https://WhistlingZephyr.github.io/posts/</link><description>Recent content in Posts on Zephyr's Hub</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 01 Feb 2023 12:39:18 +0530</lastBuildDate><atom:link href="https://WhistlingZephyr.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Into the Rabbit Hole: A Game of Data</title><link>https://WhistlingZephyr.github.io/posts/a-game-of-data/</link><pubDate>Wed, 01 Feb 2023 12:39:18 +0530</pubDate><guid>https://WhistlingZephyr.github.io/posts/a-game-of-data/</guid><description>Introduction In this post, we&amp;rsquo;ll find a way to list all countries, states, and capital cities starting and ending with the same letter, where the letter can&amp;rsquo;t be &amp;ldquo;a&amp;rdquo;, using Wikidata and SPARQL.
Background So one day (2022-Dec-14 to be specific) I was hanging out on Discord in the Rust Programming Language Community Server, and Dylan there gave me a fun challenge to solve: He said that he was trying to name all important places (such as countries, states, and major cities) that start and end with the same letter that isn&amp;rsquo;t &amp;ldquo;A&amp;rdquo; (because there are quite bunch that start and end with &amp;#34;A&amp;#34;).</description><content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>In this post, we&rsquo;ll find a way to list all countries, states, and capital cities
starting and ending with the same letter, where the letter can&rsquo;t be &ldquo;a&rdquo;, using
<a href="https://www.wikidata.org/wiki/Wikidata:Main_Page">Wikidata</a> and <a href="https://en.wikipedia.org/wiki/SPARQL">SPARQL</a>.</p>
<h2 id="background">Background</h2>
<p>So one day <small>(2022-Dec-14 to be specific)</small> I was hanging out on Discord in the <a href="https://discord.gg/rust-lang-community">Rust Programming Language Community Server</a>, and <a href="https://github.com/Dylan-DPC">Dylan</a> there gave me a fun challenge to solve: He said that he was trying to name all important places <small>(such as countries, states, and major cities)</small> that start and end with the same letter that isn&rsquo;t &ldquo;A&rdquo; <small>(because there are quite bunch that start and end with &#34;A&#34;)</small>. Well, I raised the concern that differentiating between major and non-major cities is likely going to be difficult, so I ended up ended up considering only capital cities in its place. I determined that I needed a way to get a list of all the world&rsquo;s countries, states, and capital cities first; and right off the bat, Wikidata seemed like the best place to start. That day, I learnt a bit of SPARQL and jotted down a basic <a href="https://w.wiki/678J">query</a> to find the solution. Although, that solution wasn&rsquo;t perfect; so let&rsquo;s try coming up with something better this time.</p>
<blockquote>
<p>Note: I&rsquo;m aware there are alternative ways to approach this problem; however, I&rsquo;ll be using Wikidata&rsquo;s Query Service with SPARQL to solve this rather than approaching it in a different way, for example using the graphical query builder to get a list of places and then filtering through in with a different language.</p>
</blockquote>
<h2 id="before-we-start">Before we start</h2>
<ul>
<li><strong>Wikidata</strong> is a knowledge database. It contains millions of statements, such as “the capital of Canada is Ottawa”, or “the Mona Lisa is painted in oil paint on poplar wood”, or “gold has a melting point of 1,064.18 degrees Celsius”.</li>
<li><strong>SPARQL</strong> is a language to formulate questions <small>(queries)</small> for knowledge databases. With the right database, a SPARQL query could answer questions like “what is the most popular tonality in music?” or “which character was portrayed by the most actors?” or “what’s the distribution of blood types?” or “which authors’ works entered the public domain this year?”. The acronym &ldquo;SPARQL&rdquo; stands for &ldquo;SPARQL Protocol And RDF Query Language&rdquo;.</li>
<li><strong>RDF</strong> stands for &ldquo;Resource Description Framework&rdquo;, it&rsquo;s used as a general method for describing and exchanging graph data, and it&rsquo;s what SPARQL queries.</li>
<li><strong>WDQS</strong>, the Wikidata Query Service, brings the two together: You enter a SPARQL query, it runs it against Wikidata’s dataset and shows you the result.</li>
</ul>
<h2 id="digging-up">Digging up</h2>
<p>We can query Wikidata with SPARQL at <a href="https://query.wikidata.org/">https://query.wikidata.org/</a>. A simple SPARQL query looks like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?a</span> <span class="nv">?b</span> <span class="nv">?c</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="err">x</span> <span class="err">y</span> <span class="nv">?a</span><span class="p">.</span>
  <span class="err">m</span> <span class="err">n</span> <span class="nv">?b</span><span class="p">.</span>
  <span class="nv">?b</span> <span class="err">f</span> <span class="nv">?c</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>The <code>SELECT</code> clause is what you want to output and the <code>WHERE</code> clause contains constraints to filter said output with. Variables start with <code>?</code>, they&rsquo;re placeholders that you can tie constraints to. Inside the <code>WHERE</code> clause are &ldquo;triples&rdquo;. Triples are how RDF stores relations. A triple is like a sentence: it has a <em>subject</em>, <em>predicate</em>, and <em>object</em>; terminated by a period. The predicate here is a property the subject has, and the subject and object themselves are considered items.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?fruit</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="nv">?fruit</span> <span class="err">color</span> <span class="err">yellow</span><span class="p">.</span>
  <span class="nv">?fruit</span> <span class="err">taste</span> <span class="err">sour</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div><p>On Wikidata, items and properties aren&rsquo;t identified by human-readable names, instead they&rsquo;re assigned to an identifier. To find the identifier for an item or property, we <a href="https://www.wikidata.org/wiki/Special:Search">search</a> for the item&rsquo;s Q-number with &ldquo;search term&rdquo; or the property&rsquo;s P-number with &ldquo;P:search term&rdquo;.</p>
<p>We need to also include prefixes in our non-variable identifiers. In this case, we use the <code>wd:</code> prefix for items and <code>wdt:</code> prefix for properties. There are more prefixes listed (<a href="https://www.wikidata.org/wiki/EntitySchema:E49">here</a>), but we won’t be needing those for this post.</p>
<p>Let&rsquo;s find a list of all countries. We can start by searching an example country to know what we&rsquo;re dealing with. I&rsquo;ll go with Germany. Searching &ldquo;Germany&rdquo; in WikiData tells us that its identifier is <a href="https://www.wikidata.org/wiki/Q183">Q183</a>, and there it&rsquo;s &ldquo;instance of&rdquo; a &ldquo;country&rdquo;, in which &ldquo;instance of&rdquo; and &ldquo;country&rdquo; are <a href="https://www.wikidata.org/wiki/Property:P31">P31</a> and <a href="https://www.wikidata.org/wiki/Q6256">Q6256</a> respectfully. Let&rsquo;s also limit our query to the first 100 results, we can use a <code>LIMIT</code> clause for that with a number. Last but not least, we need a labeling service, because by default Wikidata only shows the identifiers of result items. For each variable <code>?foo</code>, we can add its label <code>?fooLabel</code> by including <code>SERVICE wikibase:label { bd:serviceParam wikibase:language &quot;en&quot;. }</code> in our <code>WHERE</code> clause. So at the end, our query for getting a list of countries ends up looking like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?countryLabel</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span> <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span>
  <span class="k">SERVICE</span> <span class="nn">wikibase</span><span class="p">:</span><span class="nt">label</span> <span class="p">{</span> <span class="nn">bd</span><span class="p">:</span><span class="nt">serviceParam</span> <span class="nn">wikibase</span><span class="p">:</span><span class="nt">language</span> <span class="s">&#34;en&#34;</span><span class="p">.</span> <span class="p">}</span>
<span class="p">}</span>
<span class="k">LIMIT</span> <span class="mi">100</span>
</code></pre></div><p>The <a href="https://w.wiki/6HC4">result</a> shows a list of 100 countries as we desired. Let&rsquo;s make it show the starting character of each country alongside. We can use <code>BIND(expression AS ?variable)</code> to define a variable from an expression and <code>SUBSTR(string, beginPosition, stringLength)</code> to get a substring of a string; the position index starts at 1.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?countryLabel</span> <span class="nv">?countryStart</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span> <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">.</span>
  <span class="k">SERVICE</span> <span class="nn">wikibase</span><span class="p">:</span><span class="nt">label</span> <span class="p">{</span> <span class="nn">bd</span><span class="p">:</span><span class="nt">serviceParam</span> <span class="nn">wikibase</span><span class="p">:</span><span class="nt">language</span> <span class="s">&#34;en&#34;</span><span class="p">.</span> <span class="p">}</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?countryStart</span><span class="p">).</span>
<span class="p">}</span>
<span class="k">LIMIT</span> <span class="mi">100</span>
</code></pre></div><p>Running that query, we see that the <a href="https://w.wiki/6HE4">results</a> don&rsquo;t actually show anything in the <code>countryStart</code> row. It&rsquo;s because even though we learned to use the <code>wikibase:label</code> service for fetching labels of our identifiers, we can&rsquo;t actually access the labels inside our <code>WHERE</code> clause yet. We can fetch labels manually using the <code>rdfs:label</code> property.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?countryLabel</span> <span class="nv">?countryStart</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span> <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">.</span>
  <span class="nv">?country</span> <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?countryLabel</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?countryStart</span><span class="p">).</span>
<span class="p">}</span>
<span class="k">LIMIT</span> <span class="mi">100</span>
</code></pre></div><p>However, in the <a href="https://w.wiki/6HE5">result</a> we see that we get outputs from other languages as well. To fix that, we can use the <code>FILTER</code> function combined with the <code>LANG</code> function, and using <code>=</code> as the comparison operator.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?countryLabel</span> <span class="nv">?countryStart</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span> <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">.</span>
  <span class="nv">?country</span> <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?countryLabel</span><span class="p">.</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">LANG</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;en&#34;</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?countryStart</span><span class="p">).</span>
<span class="p">}</span>
<span class="k">LIMIT</span> <span class="mi">100</span>
</code></pre></div><p>The <a href="https://w.wiki/6HE7">result</a> produces the expected output. We can make this query a bit more concise.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?countryLabel</span> <span class="nv">?countryStart</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span> <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">;</span>
           <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?countryLabel</span><span class="p">.</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">LANG</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;en&#34;</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?countryStart</span><span class="p">).</span>
<span class="p">}</span>
<span class="k">LIMIT</span> <span class="mi">100</span>
</code></pre></div><p>in SPARQL, <code>a b c. a d e.</code> is the same as <code>a b c; d e.</code>. Now since we&rsquo;ll be comparing the starting character with the ending character, we can lowercase it using the <code>LCASE</code> function. And to get the last character of a string, we&rsquo;ll need the position of its last character, which is its length; we can get that with the <code>STRLEN</code> function. And we can remove our limit now, since there aren&rsquo;t many countries that match our requirement.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?countryLabel</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span> <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">;</span>
           <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?countryLabel</span><span class="p">.</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">LANG</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;en&#34;</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">LCASE</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">AS</span> <span class="nv">?countryStart</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">,</span> <span class="nf">STRLEN</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?countryEnd</span><span class="p">).</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nv">?countryStart</span> <span class="o">=</span> <span class="nv">?countryEnd</span><span class="p">).</span>
<span class="p">}</span>
</code></pre></div><p>The <a href="https://w.wiki/6HLF">result</a> gives a list of countries starting and ending with the same letter like Austria, Angola, etc. Let&rsquo;s filter out those that start and end with &ldquo;a&rdquo;, because there are too many. We can do that by adding <code>STR(?countryStart) != &quot;a&quot; &amp;&amp;</code> in our <code>FILTER</code> function call. Why are we calling <code>STR</code>? because our variable <code>?countryLabel</code> and consequently <code>?countryStart</code> and <code>?countryEnd</code> are more than just strings and contain language metadata; so to compare with a plain string, we must convert it to one first.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?countryLabel</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span> <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">;</span>
           <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?countryLabel</span><span class="p">.</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">LANG</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;en&#34;</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">LCASE</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">AS</span> <span class="nv">?countryStart</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">,</span> <span class="nf">STRLEN</span><span class="p">(</span><span class="nv">?countryLabel</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?countryEnd</span><span class="p">).</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">STR</span><span class="p">(</span><span class="nv">?countryStart</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#34;a&#34;</span> <span class="o">&amp;&amp;</span> <span class="nv">?countryStart</span> <span class="o">=</span> <span class="nv">?countryEnd</span><span class="p">).</span>
<span class="p">}</span>
</code></pre></div><p>From the <a href="https://w.wiki/6HLG">results</a>, it appears that there aren&rsquo;t many countries that fit our requirement especially when we&rsquo;re limiting our search to their English names only. Now, we can do the same for states, which is <a href="https://www.wikidata.org/wiki/Q7275">Q7275</a> and capital cities, which is <a href="https://www.wikidata.org/wiki/Q5119">Q5119</a>. We&rsquo;ll merge our selectors together with the <code>UNION</code> clause to avoid repetition. Let&rsquo;s also label which entry is what type.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?label</span> <span class="nv">?type</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="p">{</span>
    <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span>    <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;country&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span> <span class="k">UNION</span> <span class="p">{</span>
    <span class="nv">?state</span>   <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span>    <span class="nn">wd</span><span class="p">:</span><span class="nt">Q7275</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;state&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span> <span class="k">UNION</span> <span class="p">{</span>
    <span class="nv">?capital</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span>    <span class="nn">wd</span><span class="p">:</span><span class="nt">Q5119</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;capital&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">LANG</span><span class="p">(</span><span class="nv">?label</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;en&#34;</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">LCASE</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?label</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">AS</span> <span class="nv">?labelStart</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?label</span><span class="p">,</span> <span class="nf">STRLEN</span><span class="p">(</span><span class="nv">?label</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?labelEnd</span><span class="p">).</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">STR</span><span class="p">(</span><span class="nv">?labelStart</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#34;a&#34;</span> <span class="o">&amp;&amp;</span> <span class="nv">?labelStart</span> <span class="o">=</span> <span class="nv">?labelEnd</span><span class="p">).</span>
<span class="p">}</span>
</code></pre></div><p>The <a href="https://w.wiki/6HLK">results</a> match our requirements. However, there are entires missing, &ldquo;Ohio&rdquo; for example. We search it up and see that <a href="https://www.wikidata.org/wiki/Q1397">Q1397</a> Ohio is an instance of <a href="https://www.wikidata.org/wiki/Q35657">Q35657</a> U.S. state which is a subclass of <a href="https://www.wikidata.org/wiki/Q106458883">Q106458883</a> state. We on the other hand, used <a href="https://www.wikidata.org/wiki/Q7275">Q7275</a> state which appears to be different. Looking into a category that includes all our desired places such as states and provinces, we find that <a href="https://www.wikidata.org/wiki/Q107390">Q107390</a> federated state is what we&rsquo;re looking for; it also states that it&rsquo;s equivalent to <a href="https://schema.org/State">https://schema.org/State</a>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="nv">?label</span> <span class="nv">?type</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="p">{</span>
    <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span>    <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;country&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span> <span class="k">UNION</span> <span class="p">{</span>
    <span class="nv">?state</span>   <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span>    <span class="nn">wd</span><span class="p">:</span><span class="nt">Q107390</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;state&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span> <span class="k">UNION</span> <span class="p">{</span>
    <span class="nv">?capital</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span>    <span class="nn">wd</span><span class="p">:</span><span class="nt">Q5119</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;capital&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">LANG</span><span class="p">(</span><span class="nv">?label</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;en&#34;</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">LCASE</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?label</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">AS</span> <span class="nv">?labelStart</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?label</span><span class="p">,</span> <span class="nf">STRLEN</span><span class="p">(</span><span class="nv">?label</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?labelEnd</span><span class="p">).</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">STR</span><span class="p">(</span><span class="nv">?labelStart</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#34;a&#34;</span> <span class="o">&amp;&amp;</span> <span class="nv">?labelStart</span> <span class="o">=</span> <span class="nv">?labelEnd</span><span class="p">).</span>
<span class="p">}</span>
</code></pre></div><p>The <a href="https://w.wiki/6HLL">result</a> still doesn&rsquo;t have &ldquo;Ohio&rdquo;, because <a href="https://www.wikidata.org/wiki/Q1397">Q1397</a> Ohio isn&rsquo;t directly an instance of <a href="https://www.wikidata.org/wiki/Q107390">Q107390</a> federated state but rather an instance of <a href="https://www.wikidata.org/wiki/Q35657">Q35657</a> U.S. state which is a subclass of federated state. To solve it, we use <code>wdt:P31/wdt:P279*</code> as the property which says that there’s one “instance of” and then any number of “subclass of” statements between the item and the class. Also, we can <code>SELECT DISTINCT</code> instead of just <code>SELECT</code> here to avoid duplicate entires.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SPARQL" data-lang="SPARQL"><span class="k">SELECT</span> <span class="k">DISTINCT</span> <span class="nv">?label</span> <span class="nv">?type</span> <span class="k">WHERE</span> <span class="p">{</span>
  <span class="p">{</span>
    <span class="nv">?country</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span>    <span class="nn">wd</span><span class="p">:</span><span class="nt">Q6256</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;country&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span> <span class="k">UNION</span> <span class="p">{</span>
    <span class="nv">?state</span>   <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span><span class="o">/</span><span class="nn">wdt</span><span class="p">:</span><span class="nt">P279</span><span class="o">*</span> <span class="nn">wd</span><span class="p">:</span><span class="nt">Q107390</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span>        <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;state&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span> <span class="k">UNION</span> <span class="p">{</span>
    <span class="nv">?capital</span> <span class="nn">wdt</span><span class="p">:</span><span class="nt">P31</span>    <span class="nn">wd</span><span class="p">:</span><span class="nt">Q5119</span><span class="p">;</span>
             <span class="nn">rdfs</span><span class="p">:</span><span class="nt">label</span> <span class="nv">?label</span><span class="p">.</span>
    <span class="k">BIND</span><span class="p">(</span><span class="s">&#34;capital&#34;</span> <span class="k">AS</span> <span class="nv">?type</span><span class="p">).</span>
  <span class="p">}</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">LANG</span><span class="p">(</span><span class="nv">?label</span><span class="p">)</span> <span class="o">=</span> <span class="s">&#34;en&#34;</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">LCASE</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?label</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="k">AS</span> <span class="nv">?labelStart</span><span class="p">).</span>
  <span class="k">BIND</span><span class="p">(</span><span class="nf">SUBSTR</span><span class="p">(</span><span class="nv">?label</span><span class="p">,</span> <span class="nf">STRLEN</span><span class="p">(</span><span class="nv">?label</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span> <span class="k">AS</span> <span class="nv">?labelEnd</span><span class="p">).</span>
  <span class="k">FILTER</span><span class="p">(</span><span class="nf">STR</span><span class="p">(</span><span class="nv">?labelStart</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#34;a&#34;</span> <span class="o">&amp;&amp;</span> <span class="nv">?labelStart</span> <span class="o">=</span> <span class="nv">?labelEnd</span><span class="p">).</span>
<span class="p">}</span>
</code></pre></div><p>And that&rsquo;s it! Our <a href="https://w.wiki/6HLM">result</a> finally includes what seems to be all the matches. As of 2023-Jan-31 though, the result includes a place named just &ldquo;Free City of&rdquo; (<a href="https://www.wikidata.org/wiki/Q97940833">Q97940833</a>); it appears to be an error in Wikidata&rsquo;s data on that page, hopefully it&rsquo;ll get addressed soon.</p>
<h2 id="outcome">Outcome</h2>
<!-- raw HTML omitted -->
<h2 id="wrapping-up">Wrapping up</h2>
<p>So that was it, we&rsquo;ve completed our task. It&rsquo;s only the tip of the iceberg though, Wikidata and SPARQL are powerful tools that can be used together to query data related to just about anything. I hope this post gets you interested in tinkering around with it yourself. To me, programming is still just as exhilarating as the day I wrote my first hello world back in 2017.</p>
<h2 id="going-ahead">Going ahead</h2>
<p>The query can still be improved in some ways, for example:</p>
<ul>
<li>Using short names instead of full titles <small>(e.g. Electorate of Cologne -&gt; Cologne)</small> <small>(Note: this would be rather complex due to WikiData not providing a field for shorter names)</small>.</li>
<li>Including names in other languages <small>(e.g. Deutschland)</small>.</li>
<li>Removing places that existed in the past and no longer fit the criteria now or are renamed <small>(e.g. Hohenzollern-Haigerloch)</small>.</li>
</ul>
<p>And if you want to learn more about SPARQL, you can use the following resources:</p>
<ul>
<li><a href="https://www.wikidata.org/wiki/Wikidata:SPARQL_tutorial">https://www.wikidata.org/wiki/Wikidata:SPARQL_tutorial</a></li>
<li><a href="https://en.wikibooks.org/wiki/SPARQL">https://en.wikibooks.org/wiki/SPARQL</a></li>
<li><a href="https://graphdb.ontotext.com/documentation/free/sparql-functions-reference.html">https://graphdb.ontotext.com/documentation/free/sparql-functions-reference.html</a></li>
<li><a href="https://github.com/andrecastro0o/SPARQL-cheatsheet">https://github.com/andrecastro0o/SPARQL-cheatsheet</a></li>
<li><a href="https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service">https://www.wikidata.org/wiki/Wikidata:SPARQL_query_service</a></li>
<li><a href="https://mediawiki.org/wiki/Wikidata_Query_Service/User_Manual">https://mediawiki.org/wiki/Wikidata_Query_Service/User_Manual</a></li>
</ul>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Thanks to <a href="https://github.com/Dylan-DPC">@Dylan-DPC</a> for coming up with the idea and reviewing the post, and to <a href="https://github.com/Monadic-Cat">@Monadic-Cat</a> and <a href="https://github.com/Evrey/">@Evrey</a> for also reviewing the post.</p>
]]></content></item></channel></rss>